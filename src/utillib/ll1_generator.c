/*
   Cmplr Library
   Copyright (C) 2017-2018 Cong Feng <cgsdfc@126.com>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301 USA

*/

#include "ll1_generator.h"
#include "ll1_builder.h"
#include "ll1_builder_impl.h"
#include "json.h"
#include "print.h"
#include "rule.h"
#include "string.h"

/**
 * \function ll1_generator_print_EFOLLOW
 * Prints formated error information about the `FIRST/FOLLOW' conflicts
 * of the grammar.
 * The layout should be:
 * Rule A, FIRST A, Symbol B, FOLLOW B
 */
static void
ll1_generator_print_EFOLLOW(struct utillib_json_value_t *const *errs) {
  struct utillib_string str;
  for (int i = 0; i < UT_LL1_ERR_VAL_MAX; ++i) {
    utillib_json_tostring(errs[i], &str);
    char const *msg = utillib_string_c_str(&str);
    switch (i) {
    case 0:
      utillib_error_printf("Production in conflict is %s\n", msg);
      break;
    case 1:
      utillib_error_printf("The FIRST set of which is %s\n", msg);
      break;
    case 2:
      utillib_error_printf("The Symbol in conflict is %s\n", msg);
      break;
    case 3:
      utillib_error_printf("The FOLLOW set of which is %s\n", msg);
      break;
    }
  }
}

/**
 * \function ll1_generator_print_EFIRST
 * Prints formated error information about the `FIRST/FIRST' conflicts
 * of the grammar.
 * The layout of the fixed-size array `errs' should be:
 * Rule A, FIRST A, Rule B, FIRST B.
 */

static void
ll1_generator_print_EFIRST(struct utillib_json_value_t *const *errs) {
  struct utillib_string str;
  for (int i = 0; i < UT_LL1_ERR_VAL_MAX; ++i) {
    utillib_json_tostring(errs[i], &str);
    char const *msg = utillib_string_c_str(&str);
    switch (i) {
    case 0:
    case 2:
      utillib_error_printf("Production in conflict is %s\n", msg);
      break;
    case 3:
    case 1:
      utillib_error_printf("FIRST set of which is %s\n", msg);
      break;
    }
    utillib_string_destroy(&str);
  }
}

/**
 * \file utillib/ll1_generator.c
 * Frontend of the Utillib.LL(1).
 */

static void
ll1_generator_print_error(struct utillib_ll1_builder_error const *error) {
  utillib_error_printf("ERROR: %s\n",
                       utillib_ll1_error_kind_tostring(error->kind));
  switch (error->kind) {
  case UT_LL1_EFIRST:
    ll1_generator_print_EFIRST(error->values);
    break;
  case UT_LL1_EFOLLOW:
    ll1_generator_print_EFOLLOW(error->values);
    break;
  }
  utillib_error_printf("\n");
}

static bool ll1_generator_check_table(struct utillib_ll1_generator *self) {
  struct utillib_ll1_builder *builder = &self->builder;
  size_t error_size = utillib_ll1_builder_check(builder);
  if (0 == error_size)
    return true;
  struct utillib_vector const *errors = &builder->errors;
  UTILLIB_VECTOR_FOREACH(struct utillib_ll1_builder_error const *, err,
                         errors) {
    ll1_generator_print_error(err);
  }
  utillib_error_printf("%lu errors detected.\n", error_size);
  return false;
}

/**
 * \function ll1_generator_table_tostring
 * Fills in a string with the LL(1) table in C
 * `int[][]' format.
 */

static void ll1_generator_write_table(struct utillib_ll1_generator *self,
                                      FILE *file) {
  struct utillib_rule_index const *rule_index = &self->rule_index;

  fputs("static int ll1_parser_table[]={\n", file);

  for (int i = 0; i < rule_index->non_terminals_size; ++i) {
    fputs("\t", file);
    for (int j = 0; j < rule_index->terminals_size; ++j) {
      struct utillib_rule const *rule = utillib_vector2_at(&self->table, i, j);
      int rule_id;
      if (NULL == rule) {
        rule_id = UT_RULE_NULL;
      } else if (rule == UTILLIB_RULE_EPS) {
        rule_id = UT_RULE_EPS;
      } else {
        rule_id = rule->id;
      }
      fprintf(file, "%4d, ", rule_id);
    }
    fputs("\n", file);
  }
  fputs("};\n", file);
}

static void ll1_generator_write(struct utillib_ll1_generator *self,
                                FILE *file) {
  fputs(utillib_LICENSE_str, file);
  fputs("\n", file);
  fputs("/* LL(1) parser table */\n"
        "/* Generated by Utillib.LL(1). DONNOT EDIT !*/\n",
        file);
  ll1_generator_write_table(self, file);
}

void utillib_ll1_generator_init_from_code(
    struct utillib_ll1_generator *self, struct utillib_symbol const *symbols,
    struct utillib_rule_literal const *rules) {
  utillib_rule_index_init(&self->rule_index, symbols, rules);
  utillib_ll1_builder_init(&self->builder, &self->rule_index);
  utillib_ll1_builder_build_table(&self->builder, &self->table);
}

bool utillib_ll1_generator_generate(struct utillib_ll1_generator *self,
                                    const char *filename) {
  if (!ll1_generator_check_table(self))
    return false;
  FILE *file = fopen(filename, "w");
  if (!file) {
    perror("ERROR");
    return false;
  }
  ll1_generator_write(self, file);
  fclose(file);
  return true;
}

void utillib_ll1_generator_dump(struct utillib_ll1_generator *self,
    const char *filename)
{

}

void utillib_ll1_generator_destroy(struct utillib_ll1_generator *self) {
  utillib_rule_index_destroy(&self->rule_index);
  utillib_ll1_builder_destroy(&self->builder);
  utillib_vector2_destroy(&self->table);
}
